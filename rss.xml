<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
<channel>
    <title>Everything Burns</title>
  <link>https://jimfl.github.io/everything-burns/</link>
  <description>Re-ignited</description>
  <lastBuildDate>Sat, 31 Dec 22 17:54:13 +0000</lastBuildDate>
  <language>en-us</language>

  <item>
  <title>Cable Management Hack</title>
  <description><![CDATA[
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>Cable Management Hack - Everything Burns</title>
    <link rel="stylesheet" href="/everything-burns/assets/css/style.css">
    <link rel="stylesheet" href="/everything-burns/assets/css/prism.css">
    
<link rel="alternate" type="application/rss+xml" title="Feed for Everything Burns" href="https://jimfl.github.io/everything-burns/rss.xml" />

  </head>
  <body>
    <div id="wrapper">
      <header id="top">
<h1><a href="/everything-burns/">Everything Burns</a></h1>
<p>Re-ignited</p>
</header>
      <nav>
<ul>
  <li><a href="/everything-burns/index.html">Home</a></li>
  <li><a href="/everything-burns/posts">Posts</a></li>
  <li>Mastodon: <a rel="me" href="https://hachyderm.io/@jimfl">@jimfl@hachyderm.io</a></li>
</ul>
</nav>
      <hr>
      <main><article class="post"><header><h1 id="cable-management-hack">Cable Management Hack</h1><p>
      Thursday, 29 Dec 2022
      
        <span class="tags">
          Tags:
          
            <a class="tag" href="/everything-burns/tags/diy">diy</a><a class="tag" href="/everything-burns/tags/hack">hack</a></span></p></header><div><p>I have a desk that has a very nice, metal cable management grille attached to the rear legs, which is one
of the reasons I bought the desk. </p><p><img src="/everything-burns/media/noodlemgmt/grille.jpg" alt="Cable Management Grille"/></p><p>What I found though is that over time, it just became a very visible 
jumble of wires and zip ties. Making any changes was a pain. I have been
itching to tear it out and re-do the cabling to make it pretty again, but
I knew that eventually it would just get jumbled again. I started to noodle
about ways to keep cables secure, but in a flexible, easy to modify way.</p><p>After some noodling, I finally arrived at pool noodles, which we just happen
to have lying around. Here’s what I came up with. Slice the noodle along the
length. The excess cables go into the slot and hang out in the cavity.</p><p>I wanted to run cables through the entire length of the tube if need be, so I
couldn’t just zip tie the whole noodle around the outer circumference to the
grid. So I drilled some holes in the back side  of the pool noodle, and run the
zip tie through that, along the length of the tube.</p><p><img src="/everything-burns/media/noodlemgmt/noodle_hack.png" alt="split noodle"/></p><p>I put three sets of zip tie holes along the 32in. length of pool noodle, and
connected it to the back side  of the grille, facing the wall. It isn’t really
visible from the front side (where I’ve attached a power strip and a power
brick).</p><p>This works great. I discovered that I don’t even have to stuff the whole cable
into the cavity like I originally envisioned, I can just take  the slack into a
loop, and jam the loop into the slot. This makes it easy to re-arrange things as 
needed.</p></div></article></main>
      <hr>
      <footer>
        
<!--=====================================-->
<!-- Override "includes/footer.html.eex" -->
<!-- to customize your footer contents.  -->
<!--=====================================-->

        <p>
          Powered by <a href="https://github.com/Dalgona/Serum">Serum</a> v1.5.1,
          with <a href="https://github.com/Dalgona/serum-theme-essence">Essence</a> theme
        </p>
      </footer>
    </div>
    <script src="/everything-burns/assets/js/prism.js"></script>
  </body>
</html>
<script>
const ws_url = "ws://" + location.host + "/serum_live_reloader";
var ws;

connect();

function connect() {
  ws = new WebSocket(ws_url);
  ws.onmessage = onMessage;
  ws.onclose = onClose;
}

function onMessage(e) {
  if (e.data === "reload") {
    location.reload();
  }
}

function onClose(e) {
  console.warn("WebSocket disconnected from server. Reconnecting in 10 seconds.");
  setTimeout(connect, 10000)
}
</script>
]]></description>
  <pubDate>Sat, 31 Dec 22 17:54:13 +0000</pubDate>
  <link>https://jimfl.github.io/everything-burns/posts/2022-12-29-cable-management-hack.html</link>
  <guid>https://jimfl.github.io/everything-burns/posts/2022-12-29-cable-management-hack.html</guid>
</item>
<item>
  <title>Obligatory Colophon</title>
  <description><![CDATA[
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>Obligatory Colophon - Everything Burns</title>
    <link rel="stylesheet" href="/everything-burns/assets/css/style.css">
    <link rel="stylesheet" href="/everything-burns/assets/css/prism.css">
    
<link rel="alternate" type="application/rss+xml" title="Feed for Everything Burns" href="https://jimfl.github.io/everything-burns/rss.xml" />

  </head>
  <body>
    <div id="wrapper">
      <header id="top">
<h1><a href="/everything-burns/">Everything Burns</a></h1>
<p>Re-ignited</p>
</header>
      <nav>
<ul>
  <li><a href="/everything-burns/index.html">Home</a></li>
  <li><a href="/everything-burns/posts">Posts</a></li>
  <li>Mastodon: <a rel="me" href="https://hachyderm.io/@jimfl">@jimfl@hachyderm.io</a></li>
</ul>
</nav>
      <hr>
      <main><article class="post"><header><h1 id="obligatory-colophon">Obligatory Colophon</h1><p>
      Wednesday, 21 Dec 2022
      
        <span class="tags">
          Tags:
          
            <a class="tag" href="/everything-burns/tags/elixir">elixir</a><a class="tag" href="/everything-burns/tags/meta">meta</a></span></p></header><div><p>A few notes on history and how this site is put together. </p><p>In 2001, I discovered and embraced the weblog phenomenon, and maintained a personal blog, running on a 
dusty linux box under my desk, likely in violation of my DSL terms of service. I ran that blog until 2005,
when ne’er-do-wells exploited a zero-day vulnerability in the wiki software I was running on the same box,
and trashed the system. “Certainly, you had backups,” you might be asking. Well, allow me to retort. I did
not. So, I moved on with my life, and embraced Twitter instead, leaving that platform in 2016 for obvious
reasons.</p><p>That blog, Everything Burns, is still more or less archived on archive.org. Here are some screenshots of the 
header over time:</p><p><img src="/everything-burns/media/old-eb/eb1.png" alt="Original Everything Burns header"/><img src="/everything-burns/media/old-eb/eb2.png" alt="Original Everything Burns header"/><img src="/everything-burns/media/old-eb/eb3.png" alt="Original Everything Burns header"/></p><p>When I retired from software development, I decided that I wanted to have a place to write again, but on
my terms.</p><ul><li>Not self-hosted, but I have full control of the content in neutral format, like Markdown.
</li><li>Movable. I can re-host if needed.
</li><li>Customizable, so that I can add features if need be
</li><li>Supports blog posts and other non-blog type content (plain pages)
</li></ul><p>In terms of hosting, I don’t really want to have a personal domain. I settled on github pages as the hosting
solution, and started looking for a suitable, extensible static website generation tool. <a href="https://jekyllrb.com/">Jekyll</a>
seemed pretty powerful and theme-able, but I rejected it out of hand because Ruby. If I was going to
reject a solution based on language, I thought I might search for a solution based on language, and
started looking for an Elixir-based static site generator. I found <a href="https://dalgona.github.io/Serum/">Serum</a>,
which should look familiar.</p><p>Even though serum supports themes, I haven’t yet been arsed to change from the default theme. This is a contrast 
from the previous incarnation when I would spend hours editing MovableType templates and piddling around in
The Gimp. I did end up adding RSS support, via the event hooks facility, and that was really straightforward.</p><p>The workflow for creating a post involves using a <code class="inline">mix</code> task that comes with serum:</p><pre><code class="">$ mix serum.gen.blog --title &quot;Obligatory Colophon&quot; --output obligatory-colophon</code></pre><p>Then editing the resulting Markdown file (I am using the <a href="https://helix-editor.com/">Helix</a> editor, which
may deserve a separate post in itself.)</p><pre><code class="">---
title: Obligatory Colophon
date: 2022-12-21 09:05:48
tags: meta
---

A few notes on history and how this site is put together. </code></pre><p>I can view the whole site locally as I edit with another <code class="inline">mix</code> task that runs a server on localhost.</p><p>To publish, I just </p><pre><code class="">$ mix serum.build 
$ cd site
$ git add .
$ git commit -m &quot;I wrote a thing&quot;
$ git push origin main  </code></pre><p>and a few minutes later the post appears and is in the RSS feed.</p><p>I can operate this setup from any desktop operating system. Presently I am using MacOS. </p><p>And yes, I have backups.</p></div></article></main>
      <hr>
      <footer>
        
<!--=====================================-->
<!-- Override "includes/footer.html.eex" -->
<!-- to customize your footer contents.  -->
<!--=====================================-->

        <p>
          Powered by <a href="https://github.com/Dalgona/Serum">Serum</a> v1.5.1,
          with <a href="https://github.com/Dalgona/serum-theme-essence">Essence</a> theme
        </p>
      </footer>
    </div>
    <script src="/everything-burns/assets/js/prism.js"></script>
  </body>
</html>
<script>
const ws_url = "ws://" + location.host + "/serum_live_reloader";
var ws;

connect();

function connect() {
  ws = new WebSocket(ws_url);
  ws.onmessage = onMessage;
  ws.onclose = onClose;
}

function onMessage(e) {
  if (e.data === "reload") {
    location.reload();
  }
}

function onClose(e) {
  console.warn("WebSocket disconnected from server. Reconnecting in 10 seconds.");
  setTimeout(connect, 10000)
}
</script>
]]></description>
  <pubDate>Sat, 31 Dec 22 17:54:13 +0000</pubDate>
  <link>https://jimfl.github.io/everything-burns/posts/2022-12-21-obligatory-colophon.html</link>
  <guid>https://jimfl.github.io/everything-burns/posts/2022-12-21-obligatory-colophon.html</guid>
</item>
<item>
  <title>Signing Is Not Trivial</title>
  <description><![CDATA[
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>Signing Is Not Trivial - Everything Burns</title>
    <link rel="stylesheet" href="/everything-burns/assets/css/style.css">
    <link rel="stylesheet" href="/everything-burns/assets/css/prism.css">
    
<link rel="alternate" type="application/rss+xml" title="Feed for Everything Burns" href="https://jimfl.github.io/everything-burns/rss.xml" />

  </head>
  <body>
    <div id="wrapper">
      <header id="top">
<h1><a href="/everything-burns/">Everything Burns</a></h1>
<p>Re-ignited</p>
</header>
      <nav>
<ul>
  <li><a href="/everything-burns/index.html">Home</a></li>
  <li><a href="/everything-burns/posts">Posts</a></li>
  <li>Mastodon: <a rel="me" href="https://hachyderm.io/@jimfl">@jimfl@hachyderm.io</a></li>
</ul>
</nav>
      <hr>
      <main><article class="post"><header><h1 id="signing-is-not-trivial">Signing Is Not Trivial</h1><p>
      Thursday, 15 Dec 2022
      
        <span class="tags">
          Tags:
          
            <a class="tag" href="/everything-burns/tags/cryptography">cryptography</a><a class="tag" href="/everything-burns/tags/signing">signing</a><a class="tag" href="/everything-burns/tags/systems">systems</a></span></p></header><div><p>I hear something akin to the following a lot: “This problem
is simply solved by (cryptographic) signing.”</p><p>Over the last half-decade, I’ve always responded in the moment with a
laundry list of all of the things around signing that need to be built at
whatever scale (corporate, community, Internet), so I decided to collect
my thoughts about it here, so I can reference it later.</p><p>What follows is not really about cryptography at all. I would apologize in
advance for this, but you really don’t want me writing about cryptography. My
point of view is as builder, not cryptographer. Taking cryptographic signatures
as a primitive, it talks about what kinds of things are needed build robust,
usable systems that use signing to provide authenticity, integrity, and
authorization controls.</p><h2 id="cryptographic-signatures">Cryptographic Signatures</h2><p>Of course, modulo the mathematics involved, and ensuring the cryptographic
implementations are coded soundly, signing things and verifying the signatures
is extraordinarily simple. If I have a public-key cryptosystem key pair of some
sort, I can use the private part of the key—known only to me—to produce a
signature over the cryptographic digest of some data (any old bag of bits).
Having shared my public key, anyone who can retrieve the public key is able to
verify that the signature was produced with the private part of the key. What
could be simpler?</p><p>I suspect this is the mental model of most who assert that “this problem is
simply solved by signing.” And it’s more or less correct. But it is far
from complete. Let’s explore what other problems need to be solved in support
of signing, especially if the problem is many-to-many and/or at scale.</p><h2 id="private-key,-known-only-to-me">Private key, Known only to me</h2><p>Most every cryptographic signature mechanism depends upon the security of
the private key. The private key is a chunk of binary data which needs to be
present at the time, and in the environment of signing. In the simple model
above, disclosure of the key allows an attacker to produce signatures that
appear to be valid and come from the legitimate owner of the key. Since the
key is just data which can be duplicated <em>ad infinitum</em> without diminishing
any single copy, there is nothing to make it obvious either to the key owner or
other stakeholders that this has happened.</p><p>So the very first “feature” that we owe in a secure signing system is the
security of the signing environment. What makes this particularly challenging
is that we usually want to make our system available to a diverse set of
users using various operating systems and other tools. If the generation and
management of the key material is commonly left up to the users of the system,
we may need to consider building protections against the legitimate users of
the system, because it isn’t always possible to govern how key material is
managed.</p><p>Uncertainty about the safety of key material is one of the reasons you may see
keys that expire after a certain period of time, limiting the blast radius of
a key exposure. However, if you want to consider a signature to be valid after
the key that produced it has expired, you need to embed authenticated time
information into the signature, which involves more keys and signatures, and
compounds every other problem laid out in what follows. Also, if the security
of your system depends on knowing what time it is, you’ve got more problems.</p><p>One key security strategy is hardware cryptography modules, which at least make
it more obvious when the user no longer has control over the key material. Another
is single-use keys which are created upon a proper authentication by the user
into a centralized system, and where the keys or signatures are countersigned
by that system. In both of these strategies, the signing user needn’t even be exposed to
the key material in order to mishandle it. </p><h2 id="verifying-signatures">Verifying Signatures</h2><p>In order to verify a signature, I need to obtain the public key of the signer.
When it’s just Alice and Bob, this is straightforward. In a larger many-party
system, some mechanism of discovering public key information is needed, not
merely as a convenience, but as a security measure; an attacker might fool
me into thinking something is signed by a legitimate party, by replacing the
public key I am using for verification with a false one.</p><p>A common strategy for this is to provide a directory of public key information,
called a key server. Verifying parties will need to trust this key server
to provide the legitimate key material. The key-server strategy requires the
verifying environment to have connectivity, which is not always viable (think
IoT devices or air-gapped environments).</p><p>Public key certificates (PKI) are often a way to manage key material in such
a way that signatures can be verified in air-gapped environments. The public
key material is sent along with the signature, and is signed by a chain of
certificates signed by one or more root certificates, which are pre-loaded into
the verification environment. As long as the signature chains all the way to
a root that you trust, you have some assurance that the correct public key is
present for the stated identity of the signer.</p><p>Depending upon what is at stake, (per the threat model of the system. You do
have a threat model, right?), any strategy for distributing public key material
must authenticate users before they can publish key material to the key
server. For example, paying for the key-server entry with a credit card (like
you might do for your Apple developer account), or, in the case of web-server
certificates, demonstrating that you have control over a domain by placing an
entry in that domain’s DNS records, or placing some data in a web page in that
domain.</p><p>Once the secure distribution of public keys is solved, there is still the fact
that verification is done in diverse environments, where it is not possible
to govern the security and hygiene of the public key material. If an attacker 
is able to manipulate local stores of public key material, they can trick a
verifier into trusting a signature which they should not. PKI certificate trust
stores are an example of such an attack vector. </p><h2 id="authorization">Authorization</h2><p>The foregoing section was primarily about making sure you have an authentic
public key with which to verify that an identity produced a signature, and now
you can verify the signature. That’s essentially an authentication operation.
The next question I might want to answer is: why do I believe that the
authenticated identity was the right one to have produced this signature. This
depends on the semantics of the signature. If it’s an email from Alice to Bob,
Bob can visually verify that the signature was produced by Alice.</p><p>Consider a situation where it is repeatedly proposed that signing is a
solution: open source package repositories. It is suggested that many of
the attacks where malicious code is substituted for genuine code in these
repositories could have been prevented by signing the code. For a software
project of any complexity, the dependency tree may comprise hundreds or
thousands of packages from multiple repositories. Not only would obtaining
the public key material and checking all of those signatures be cumbersome,
something is needed to help the verifier understand that the signatures were
produced by those authorized to do so (i.e. the package maintainers). As far
as I am aware, highly ramified authorization like this is an unsolved problem,
but that may be due to my prejudice against trying to apply blockchain to every
problem I happen across.</p><h2 id="when-things-go-wrong">When Things Go Wrong</h2><p>Of course, all of the above is just getting the happy path to work. Keys will
get compromised. Individuals will lose trust and need to be de-authourized
to produce signatures for some or all of the capabilities granted by their
ability to sign. Registries and key-servers will have defects. And so, systems
need to be in place to manage the key material and other configurations, and
the mechanisms need to be understood by systems running in signing environments
as well as verification environments.</p><h3 id="blast-radius">Blast radius</h3><p>Some of the protective mechanisms can be somewhat automatic. By constraining
the scope of how and when key material can be used, compromises can self-heal
after some time, or only expose a subset of the problem space.</p><p>The easiest example to draw on is the validity period of PKI certificates.
Certificates are chained in hierarchies from a heavily protected root, down
to the leaf-node certificates given to unwashed masses to use. These leaf
certificates often are valid for very short periods of time (hundreds of
days) compared to the roots (decades), so if one is compromised it will stop
being a problem eventually. Using PKI certificates to sign digital assets is
complicated by this, because I generally want the signature on my asset to be
valid beyond the validity period of the key itself (meaning I cannot produce
any more signatures with that key, but I want continue to trust signatures that
were produced while the key itself was valid). Using PKI for signing digital
assets can use a technique called timestamping, where a trusted third party
countersigns a signature with an authenticated timestamp, attesting that the
signature was submitted to the timestamper while the key was valid.</p><p>Expiration dates on certificates cause a lot of problems. It is said that
everyone has a cryptographically signed timestamp for when their website or
service will stop working, embedded in a certificate somewhere. Most people get
a certificate then stop worrying about it until 180 days later when stuff stops
working. They scramble about, get another certificate, then stop worrying for
another 180 days. Even though the glue on sticky notes continues to improve,
this is a perennial problem.</p><p>It’s even worse when a custodian of public key infrastructure (like a
certificate authority, ISP, or cloud provider) has an accidental expiration.
The blast radius of these events can take half the internet down.</p><h3 id="explicit-controls">Explicit controls</h3><p>Often, blast radius measures aren’t enough, and a key needs to be revoked
immediately. This requires a communications channel between the key
distribution mechanism and verifying systems (which may cache keys), once again
requiring connectivity in order to make sure you have the most up-to-date
information about which keys are valid and which are not.</p><h3 id="expect-signature-verification-to-fail">Expect signature verification to fail</h3><p>Another thing that can be overlooked is what happens when a signature fails to
verify. This really should be among the in-band use cases, but the nuances of
failed verifications are often discovered in root-cause analysis of failures
due to invalid or missing signatures. Signatures can fail to verify for a
variety of reasons: missing signatures, invalid key material, corrupted data,
maliciously modified data, infrastructure and configuration errors. It is
almost impossible to distinguish between benign and malicious causes in an
automated way.</p><p>Even within a single use case or ecosystem (consider, again, the software
package repository example), the stakes of accepting or rejecting assets with
invalid signatures vary. For example, there’s a difference between failing at
build time, when signatures are checked when packages are bound to the build,
but if you’re unfortunate enough to have a system that binds dependencies at
deployment, invalid signatures at this stage could cause some chaos without
careful thought.</p><p>Any sufficiently complex signing system should give the verifier enough
detailed information, tools, or hooks to make decisions about what happens when
signatures fail. This decision making process needs to be flexible enough so
that it is easy to configure across multiple verification environments, where
the stakes or semantics of invalid signatures may differ.</p><h2 id="conclusion">Conclusion</h2><p>Not every problem where signing is employed needs all of the features described
here. When bringing signing to bear it is worth considering how simple the
system can be made and still provide the usability and security desired. PKI
attempts to address many of these problems, and falls pretty far short. Running
a large scale PKI is a major undertaking.</p><p>App signing ecosystems like Authenticode, or Apple’s AppStore have added their
own controls onto PKI, and those systems are fairly robust, though not easy for
developers to learn or use. Apple has still had issues with things like
infrastructure key material being distrusted.</p></div></article></main>
      <hr>
      <footer>
        
<!--=====================================-->
<!-- Override "includes/footer.html.eex" -->
<!-- to customize your footer contents.  -->
<!--=====================================-->

        <p>
          Powered by <a href="https://github.com/Dalgona/Serum">Serum</a> v1.5.1,
          with <a href="https://github.com/Dalgona/serum-theme-essence">Essence</a> theme
        </p>
      </footer>
    </div>
    <script src="/everything-burns/assets/js/prism.js"></script>
  </body>
</html>
<script>
const ws_url = "ws://" + location.host + "/serum_live_reloader";
var ws;

connect();

function connect() {
  ws = new WebSocket(ws_url);
  ws.onmessage = onMessage;
  ws.onclose = onClose;
}

function onMessage(e) {
  if (e.data === "reload") {
    location.reload();
  }
}

function onClose(e) {
  console.warn("WebSocket disconnected from server. Reconnecting in 10 seconds.");
  setTimeout(connect, 10000)
}
</script>
]]></description>
  <pubDate>Sat, 31 Dec 22 17:54:13 +0000</pubDate>
  <link>https://jimfl.github.io/everything-burns/posts/2022-12-15-signing-problems.html</link>
  <guid>https://jimfl.github.io/everything-burns/posts/2022-12-15-signing-problems.html</guid>
</item>
<item>
  <title>Escher-inspired Tesselations With Marked Tiles</title>
  <description><![CDATA[
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <title>Escher-inspired Tesselations With Marked Tiles - Everything Burns</title>
    <link rel="stylesheet" href="/everything-burns/assets/css/style.css">
    <link rel="stylesheet" href="/everything-burns/assets/css/prism.css">
    
<link rel="alternate" type="application/rss+xml" title="Feed for Everything Burns" href="https://jimfl.github.io/everything-burns/rss.xml" />

  </head>
  <body>
    <div id="wrapper">
      <header id="top">
<h1><a href="/everything-burns/">Everything Burns</a></h1>
<p>Re-ignited</p>
</header>
      <nav>
<ul>
  <li><a href="/everything-burns/index.html">Home</a></li>
  <li><a href="/everything-burns/posts">Posts</a></li>
  <li>Mastodon: <a rel="me" href="https://hachyderm.io/@jimfl">@jimfl@hachyderm.io</a></li>
</ul>
</nav>
      <hr>
      <main><article class="post"><header><h1 id="escher-inspired-tesselations-with-marked-tiles">Escher-inspired Tesselations With Marked Tiles</h1><p>
      Monday, 31 Oct 2022
      
        <span class="tags">
          Tags:
          
            <a class="tag" href="/everything-burns/tags/escher">escher</a><a class="tag" href="/everything-burns/tags/math">math</a><a class="tag" href="/everything-burns/tags/processing">processing</a><a class="tag" href="/everything-burns/tags/tesselations">tesselations</a></span></p></header><div><p>Some while ago (during or not too long after my college years), I
found the following page in a collection of M.C. Escher’s notebooks,
describing overlapping motifs on tiles, which, when arranged in
various rotations, result in woven designs.</p><p><img src="/everything-burns/media/escher/EscherNotebook.jpg" alt="Marked tiles from Escher&#39;s notebooks"/></p><p>Using Adobe Illustrator at the time, I experimented with some tiles
of my own. Initially I made some squares, but eventually designed some hexagonal
tiles as well.</p><p>Recently I resurrected the square designs to start working with
these by programming because it is tedious to do it by hand. Using
the <a href="http://processing.org">Processing</a> language, I made two tiles,
an “over” version and an “under” version.</p><p><img src="/everything-burns/media/escher/ExampleTiles.jpg" alt="Over and Under Tiles"/></p><p>Why they’re labeled “^” and “M” I’ll get to in a moment. Here’s a random tiling
with both tiles, in various rotations.</p><p><img src="/everything-burns/media/escher/random.png" alt="Random Square Tiling"/></p><p>Once I could draw the tiles, I wanted to create more controlled layouts, using 
<a href="https://www.sciencedirect.com/science/article/pii/S0723086908000042">tile substitution</a>.</p><p>In order to define substitution rules, I needed an alphabet to
describe both the over and under tiles, in the various rotations.
Escher used “A” and “B” with under bars to represent the “over-underness”,
and then rotated the letters. I noodled a bit with Unicode characters
that had rotations, thinking “T” and “E” (as in T and E modules)
would be nice choices for reasons that maybe one other person I know might
understand.</p><p>Being lazy, I preferred to use ASCII characters, and I settled on the following alphabet to represent the rotations of the over and under tiles:</p><pre><code class="">^ &gt; v &lt; 
M 3 W E</code></pre><p>Having an alphabet, I could now represent substitutions of one tile for a quad of 4 tiles,
like this:</p><p><img src="/everything-burns/media/escher/substitutionRule.png" alt="Substitution Rule as an image"/></p><pre><code class="">M -&gt; &lt; E
     3 &gt;</code></pre><p>or, more succinctly as</p><pre><code class="">M -&gt; &lt;E|3&gt;</code></pre><p>Now, given a ruleset like </p><pre><code class="">^ -&gt; EE|33
&gt; -&gt; MW|WM
v -&gt; 33|EE
&lt; -&gt; WM|MW
M -&gt; &lt;E|3&gt;
3 -&gt; ^v|M^
W -&gt; 3&gt;|&lt;E
E -&gt; v^|Mv</code></pre><p>Starting with an axiom of ‘^’ and doing 3 iterations of substitutions (replace the axiom, then replace each of those 4 squares, then replace each of those 16 squares…) you get 
a somewhat more orderly design.</p><p><img src="/everything-burns/media/escher/substitution.png" alt="32x32 substitution design"/></p><p>Which is represented by</p><pre><code class="">E E 3 3 E E 3 3 3 3 E E 3 3 E E E E 3 3 E E 3 3 3 3 E E 3 3 E E
3 3 E E 3 3 E E E E 3 3 E E 3 3 3 3 E E 3 3 E E E E 3 3 E E 3 3
&lt; E E E &lt; E E E &lt; E 3 3 &lt; E 3 3 &lt; E E E &lt; E E E &lt; E 3 3 &lt; E 3 3
3 &gt; 3 3 3 &gt; 3 3 3 &gt; E E 3 &gt; E E 3 &gt; 3 3 3 &gt; 3 3 3 &gt; E E 3 &gt; E E
3 3 E E 3 3 E E E E 3 3 E E 3 3 3 3 E E 3 3 E E E E 3 3 E E 3 3
E E 3 3 E E 3 3 3 3 E E 3 3 E E E E 3 3 E E 3 3 3 3 E E 3 3 E E
&lt; E 3 3 &lt; E 3 3 &lt; E E E &lt; E E E &lt; E 3 3 &lt; E 3 3 &lt; E E E &lt; E E E
3 &gt; E E 3 &gt; E E 3 &gt; 3 3 3 &gt; 3 3 3 &gt; E E 3 &gt; E E 3 &gt; 3 3 3 &gt; 3 3
3 &gt; &lt; E 3 3 E E E E 3 3 E E 3 3 3 &gt; &lt; E 3 3 E E E E 3 3 E E 3 3
&lt; E 3 &gt; E E 3 3 3 3 E E 3 3 E E &lt; E 3 &gt; E E 3 3 3 3 E E 3 3 E E
&lt; E 3 &gt; &lt; E 3 3 &lt; E E E &lt; E E E &lt; E 3 &gt; &lt; E 3 3 &lt; E E E &lt; E E E
3 &gt; &lt; E 3 &gt; E E 3 &gt; 3 3 3 &gt; 3 3 3 &gt; &lt; E 3 &gt; E E 3 &gt; 3 3 3 &gt; 3 3
E E 3 3 &lt; E 3 &gt; 3 3 E E 3 3 E E E E 3 3 &lt; E 3 &gt; 3 3 E E 3 3 E E
3 3 E E 3 &gt; &lt; E E E 3 3 E E 3 3 3 3 E E 3 &gt; &lt; E E E 3 3 E E 3 3
&lt; E E E 3 &gt; &lt; E &lt; E 3 3 &lt; E 3 3 &lt; E E E 3 &gt; &lt; E &lt; E 3 3 &lt; E 3 3
3 &gt; 3 3 &lt; E 3 &gt; 3 &gt; E E 3 &gt; E E 3 &gt; 3 3 &lt; E 3 &gt; 3 &gt; E E 3 &gt; E E
3 3 E E 3 3 E E E E 3 3 E E 3 3 3 3 E E 3 3 E E E E 3 3 E E 3 3
E E 3 3 E E 3 3 3 3 E E 3 3 E E E E 3 3 E E 3 3 3 3 E E 3 3 E E
&lt; E 3 3 &lt; E 3 3 &lt; E E E &lt; E E E &lt; E 3 3 &lt; E 3 3 &lt; E E E &lt; E E E
3 &gt; E E 3 &gt; E E 3 &gt; 3 3 3 &gt; 3 3 3 &gt; E E 3 &gt; E E 3 &gt; 3 3 3 &gt; 3 3
E E 3 3 E E 3 3 3 3 E E 3 3 E E E E 3 3 E E 3 3 3 3 E E 3 3 E E
3 3 E E 3 3 E E E E 3 3 E E 3 3 3 3 E E 3 3 E E E E 3 3 E E 3 3
&lt; E E E &lt; E E E &lt; E 3 3 &lt; E 3 3 &lt; E E E &lt; E E E &lt; E 3 3 &lt; E 3 3
3 &gt; 3 3 3 &gt; 3 3 3 &gt; E E 3 &gt; E E 3 &gt; 3 3 3 &gt; 3 3 3 &gt; E E 3 &gt; E E
3 &gt; &lt; E 3 3 E E 3 3 E E 3 3 E E 3 &gt; &lt; E 3 3 E E 3 3 E E 3 3 E E
&lt; E 3 &gt; E E 3 3 E E 3 3 E E 3 3 &lt; E 3 &gt; E E 3 3 E E 3 3 E E 3 3
&lt; E 3 &gt; &lt; E 3 3 &lt; E 3 3 &lt; E 3 3 &lt; E 3 &gt; &lt; E 3 3 &lt; E 3 3 &lt; E 3 3
3 &gt; &lt; E 3 &gt; E E 3 &gt; E E 3 &gt; E E 3 &gt; &lt; E 3 &gt; E E 3 &gt; E E 3 &gt; E E
E E 3 3 &lt; E 3 &gt; E E 3 3 E E 3 3 E E 3 3 &lt; E 3 &gt; E E 3 3 E E 3 3
3 3 E E 3 &gt; &lt; E 3 3 E E 3 3 E E 3 3 E E 3 &gt; &lt; E 3 3 E E 3 3 E E
&lt; E E E 3 &gt; &lt; E &lt; E E E &lt; E E E &lt; E E E 3 &gt; &lt; E &lt; E E E &lt; E E E
3 &gt; 3 3 &lt; E 3 &gt; 3 &gt; 3 3 3 &gt; 3 3 3 &gt; 3 3 &lt; E 3 &gt; 3 &gt; 3 3 3 &gt; 3 3</code></pre></div></article></main>
      <hr>
      <footer>
        
<!--=====================================-->
<!-- Override "includes/footer.html.eex" -->
<!-- to customize your footer contents.  -->
<!--=====================================-->

        <p>
          Powered by <a href="https://github.com/Dalgona/Serum">Serum</a> v1.5.1,
          with <a href="https://github.com/Dalgona/serum-theme-essence">Essence</a> theme
        </p>
      </footer>
    </div>
    <script src="/everything-burns/assets/js/prism.js"></script>
  </body>
</html>
<script>
const ws_url = "ws://" + location.host + "/serum_live_reloader";
var ws;

connect();

function connect() {
  ws = new WebSocket(ws_url);
  ws.onmessage = onMessage;
  ws.onclose = onClose;
}

function onMessage(e) {
  if (e.data === "reload") {
    location.reload();
  }
}

function onClose(e) {
  console.warn("WebSocket disconnected from server. Reconnecting in 10 seconds.");
  setTimeout(connect, 10000)
}
</script>
]]></description>
  <pubDate>Sat, 31 Dec 22 17:54:13 +0000</pubDate>
  <link>https://jimfl.github.io/everything-burns/posts/2022-10-31-escher.html</link>
  <guid>https://jimfl.github.io/everything-burns/posts/2022-10-31-escher.html</guid>
</item>

</channel>
</rss>
